---
title: "Clusterización de variables ambientales"
format: html
author: 
  - name: "María Suárez Muñoz"
    orcid: 0000-0003-1765-6885
    email: bv2sumum@uco.es
    affiliation: Departamento de Ingeniería Forestal, Universidad de Córdoba
date: 2025-02-03
sesion: 2
crossref:
  fig-title: Figura     # (default is "Figure")
  tbl-title: Tabla     # (default is "Table")
  title-delim: .     # (default is ":")
  fig-prefix: Figura
  tbl-prefix: Tabla
  ref-hyperlink: true
  sec-prefix: ""
  sec-labels: alpha
---

# Introducción {.unnumbered}

La evaluación y planificación de actuaciones de un área afectada por un incendio forestal puede requerir la integración de multitud de variables en una extensión amplia del territorio. La mera observación de múltiples capas de información puede no ser suficiente a la hora de tomar decisiones. Por ello, es habitual realizar análisis de la información que nos permitan combinarla. Esta combinación puede hacerse de distintas maneras, desde técnicas estadísticas a análisis multicriterio, dependiendo de las fuentes de información que consideremos y el objetivo planteado. En esta sesión exploraremos una de estas opciones, la creación de áreas homogéneas mediante clusterización.

La creación de mapas de áreas homogéneas en virtud de distintas variables ambientales es una técnica muy utilizada para planificar actuaciones en el territorio. Esto es especialmente relevante en zonas muy extensas que no pueden ser manejadas sólo aplicando el conocimiento experto. 

La idea clave de estas áreas homogéneas es que, con su creación, disponemos de una espacialización de ciertas variables, que reflejamos en un mapa. En lugar de contemplar el mundo con toda su complejidad, lo vemos sólo con la visión de las variables que hemos definido para generar dicho mapa. Es decir, podemos “leer” el territorio usando esas variables.

Por ejemplo, en una zona quemada, en lugar de tener un gradiente continuo de multitud de variables descriptoras (capacidad de regeneración, profundidad del suelo, etc) tendremos una diferenciación en zonas con características acotadas, como podrían ser “lugares con suelos poco profundos y alta insolación”. De esta forma podemos plantear actuaciones de manejo particularizadas a cada unidad homogénea.

# Flujo de trabajo {.unnumbered}

En esta práctica aplicaremos una clasificación no supervisada basada en el algoritmo k-means, del que puedes leer más [aquí](https://www.publichealth.columbia.edu/research/population-health-methods/k-means-cluster-analysis). Para ello trabajaremos desde `R` con las capas que hemos generado durante las prácticas con `qGIS`. El flujo de trabajo será el siguiente:

1. Selección de variables
2. Preparación de los datos
3. Elección del número óptimo de áreas homogéneas
4. Generación del mapa
5. Evaluación del mapa

## Selección de variables

Para la creación del mapa de áreas homogéneas en primer lugar necesitaremos definir qué variables consideramos relevantes para nuestro objetivo. Una vez definidas estas variables podremos combinarlas para generar el mapa. Es habitual que tengamos que repetir el proceso varias veces, iterando sobre distintos conjuntos de variables hasta que demos con una combinación que nos satisfaga. 

¿Qué variables crees que pueden ser útiles para nuestro caso de uso?

## Preparación de los datos

En este ejercicio utilizaremos el paquete `RStoolbox` para realizar una clasificación no supervisada. Además utilizaremos los paquetes `terra`y `raster` para trabajar con las capas. Es importante tener cuidado al trabajar con estos dos paquetes de forma simultánea ya que existe cierto solapamiento entre funciones. Por ello utilizaremos la sintaxis *paquete::funcion* cuando la llamamos, asegurándonos de estar usando la función correcta. 

```{r, eval = FALSE}
# Instalar y cargar paquetes
# install.packages("RStoolbox")
library(RStoolbox)
library(raster)
library(terra)

# Opciones de configuración
date <- "20250207"
path <- "/Users/maria.suarez.munoz/Library/CloudStorage/GoogleDrive-msuamun@go.ugr.es/My Drive/Docencia/Ecoinformatica_UGR/2024_2025/SIG_qGIS/"
```

En primer lugar cargaremos las capas con las que vamos a trabajar y las exploraremos. Entonces las apilaremos en un mismo *stack*. La función *stack* del paquete `raster` crea una pila de rásters proveniente de distintos archivos. El algoritmo k-means requiere que todas las capas "encajen" entre sí, por lo que necesitaremos apilarlas en un stack.

```{r}
# Cargar máscara
mask <- raster(paste0(path, "mask.tif")) # Máscara creada con qGIS

# Cargar capas con las que vamos a trabajar: incidencia/orientación, aridez, temperaturas, precipitaciones
capa1 <- raster(paste0(path, "....tif"))
capa2 <- raster(paste0(path, "....tif"))
...

# Explorar capas
...

# Apilar capas: 
# my_stack <- raster::stack(...)  
```

Hasta ahora hemos trabajado en `qGIS` con capas que tenían distintos  distintas resoluciones y sistemas de referencia, sin haber tenido problemas por ello. `qGIS` proyecta al vuelo las capas que no están en el mismo sistema de referencia que nuestro proyecto, aunque como dijimos es más adecuado reproyectar las capas para asegurarnos de que todos los cálculos se hacen correctamente. `R`, sin embargo, no hace casi nada "under the hood", sino que nos avisa cuando algo da problemas.

Al explorar las capas hemos visto que éstas tienen distintas propiedades. No todas están en el mismo sistema de referencia ni tienen la misma resolución, por lo que necesitamos *alinearlas*. Dos capas ráster están alineadas cuando están en el mismo sistema de referencia y tienen la misma resolución y el mismo origen. Es decir, que encajan en todos los aspectos. Por tanto, tendremos que *reproyectar* y *remuestrear* las capas que no encajan entre sí para poder apilarlas. 

```{r, eval = FALSE}
# Reproyectar
# capa1_23030 <- project(capa1, mask)
# ...

# Remuestrear: generar nueva capa con la resolución deseada
# capa1_resampled <- resample(capa1_23030, mask, method = "bilinear")
```

Es importante prestar atención al método utilizado en el remuestreado, ya que el método más adecuado dependerá de la naturaleza de nuestra variable. Una vez reproyectadas y remuestreadas nuestras capas no deberíamos tener problemas para apilarlas.

```{r, eval = FALSE}
# Apilar capas
# my_stack <- stack(...)  
# names(my_stack) <- c("...")
# plot(my_stack)
```

Por último, ya que el objetivo es generar un mapa de áreas homogéneas de la zona afectada por el incendio no tiene sentido considerar las zonas fuera del perímetro del mismo. Por ello, antes de proseguir aplicaremos una máscara a nuestro *stack*.

```{r}
# Enmascarar
# stack_masked <- stack * mask

# Necesario??
# Crear brick: La función "brick" requiere que todas las capas provengan del mismo objeto (por ejemplo, un conjunto de bandas espectrales o capas que ya estén apiladas en un stack)
# my_brick <- brick(my_stack)
```

## Elección del número óptimo de áreas homogéneas

Una vez construida nuestra pila de variables tenemos que decidir cuántas áreas son adecuadas. ...

```{r, eval = FALSE}
## Choose appropriate number of classes
# set.seed(25) # Definir semilla para los procesos aleatorios
# nClass <- 7
# algorithm <- "Hartigan-Wong"

# wss <- 0 # Initialize total within sum of squares error: wss
# for (i in 1:10) { # Look over 1 to 10 possible clusters
#   out <- unsuperClass(my_brick, nClasses=i, nStarts=i*4, nIter = 2000, norm=T, clusterMap=F, algorithm = algorithm)
#   wss[i] <- out$model$tot.withinss # Save the within cluster sum of squares
# }
# plot(1:10, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")
```

Basándonos en esta gráfica ¿cuál sería el número de clases óptimo?

```{r, eval = FALSE}
nr_optimo <- 4
```


## Generación del mapa

Ya podemos generar el mapa de áreas homogéneas deseado ejecutando la clasificación no supervisada. 

```{r, eval = FALSE}
# clust <- unsuperClass(my_brick, 
#                       nClasses = nr_optimo, 
#                       nStarts = nr_optimo*4, 
#                       nIter=2000, norm=T, clusterMap=F, algorithm = algorithm)
```

## Evaluación del mapa

Por último evaluamos el mapa obtenido y lo exportamos a un archivo ráster que podremos guardar, compartir y abrir en `qGIS` o cualquier otro SIG.

```{r, eval = FALSE}
# plot(clust$map)

# Explorar características de las zonas
# clust$model

# file_name <- paste(date, "areas_homogeneas", optimal_nclasses, "clases", sep = "_")
# terra::writeRaster(clust$map, filename = paste(path, "areas_homogeneas/capas/", file_name, ".tif", sep = ""), overwrite = FALSE)
```
