{
  "hash": "d9e76dc270b525290a3f40925b377d29",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidy data\" \nauthor: \n  - name: \"Antonio J. Pérez-Luque\"\n    orcid: 0000-0002-1747-0469\n    email: antonio.perez@inia.csic.es\n    affiliation: Instituto de Ciencias Forestales (CIFOR) | INIA-CSIC (Madrid)\ndate: 2025-01-17\nsesion: 4\nformat: \n  html:\n    toc: true\n    toc-depth: 2\n    number-sections: true\n---\n\n\n\n# Introducción\n\nLa organización de datos de forma estructurada es esencial para el análisis y la visualización. En este documento exploraremos las diferencias entre dos estructuras comunes en R: `data.frame` y `tibble`. Estas herramientas son fundamentales para trabajar de manera eficiente con datos tabulares y son pilares en la filosofía del tidyverse.\n\n![Source: [Julia Lowndes & Allison Horst](https://openscapes.org/blog/2020-10-12-tidy-data/)](images/tidy_intro.jpg){fig-align=\"center\"}\n\nPara empezar, el concepto de \"tidy data\" promueve una organización en la que cada variable es una columna, cada observación es una fila y cada tipo de unidad observacional forma una tabla. Esta estructura facilita el uso de herramientas analíticas y asegura consistencia.\n\n![Source: [Wickham & Grolemund](https://r4ds.had.co.nz/tidy-data.html)](images/tidy_data.png){fig-align=\"center\"}\n\n# `data.frame` & `tibble`\n\n## `data.frame` \n\nEl `data.frame` es la estructura más común para manejar datos tabulares en R. Fue introducida con el lenguaje base y funciona como una tabla, donde las filas representan observaciones y las columnas, variables. Esta simplicidad lo convierte en un punto de partida ideal.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  x = c(1, 2, 3),\n  y = c(\"A\", \"B\", \"C\")\n)\n\ndf \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 A\n2 2 B\n3 3 C\n```\n\n\n:::\n:::\n\n\n\n## `tibble`\n\nCon el auge del tidyverse, nació el `tibble`, una versión mejorada del `data.frame`. Diseñado para ser más consistente y amigable, este formato facilita el manejo de datos complejos y variables no sintácticas. La impresión de los datos, como veremos a continuación, es un ejemplo de su diseño optimizado.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\ntb <- tibble(\n  x = c(1, 2, 3),\n  y = c(\"A\", \"B\", \"C\"),\n  `x al cuadrado` = x^2\n) \n\ntb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n      x y     `x al cuadrado`\n  <dbl> <chr>           <dbl>\n1     1 A                   1\n2     2 B                   4\n3     3 C                   9\n```\n\n\n:::\n:::\n\n\n\n### Diferencias: impresión de datos \n\nUn aspecto práctico para destacar es cómo estas estructuras manejan la impresión de datos en la consola. Mientras que `data.frame` muestra todas las filas y columnas, lo que puede ser abrumador en grandes conjuntos de datos, el `tibble` ofrece un resumen compacto, mostrando solo una vista general.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 A\n2 2 B\n3 3 C\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(tb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n      x y     `x al cuadrado`\n  <dbl> <chr>           <dbl>\n1     1 A                   1\n2     2 B                   4\n3     3 C                   9\n```\n\n\n:::\n:::\n\n\n\n### Diferencias: manejo de tipo de datos\n\nOtro punto clave es cómo tratan los tipos de datos. En `data.frame`, las columnas de tipo carácter se convierten automáticamente en factores (a menos que se especifique lo contrario). Por otro lado, `tibble` respeta los caracteres tal como están, proporcionando un comportamiento más intuitivo en muchos casos.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  x = c(1, 2, 3),\n  y = c(\"A\", \"B\", \"C\")\n)\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  2 variables:\n $ x: num  1 2 3\n $ y: chr  \"A\" \"B\" \"C\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntb <- tibble(\n  x = c(1, 2, 3),\n  y = c(\"A\", \"B\", \"C\")\n)\nstr(tb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n $ x: num [1:3] 1 2 3\n $ y: chr [1:3] \"A\" \"B\" \"C\"\n```\n\n\n:::\n:::\n\n\n\n### Diferencias: acceso a las columnas\n\nAcceder a los datos también muestra una diferencia significativa. Con `data.frame`, se pueden usar `$` y `[]`, pero el resultado puede variar entre un vector y un data frame. En cambio, `tibble` mantiene consistencia, devolviendo siempre un tibble, a menos que se especifique lo contrario.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1]   # Devuelve un data frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x\n1 1\n2 2\n3 3\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[, 1] # Devuelve un vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntb[1]   # Devuelve un tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n      x\n  <dbl>\n1     1\n2     2\n3     3\n```\n\n\n:::\n\n```{.r .cell-code}\ntb[, 1] # Devuelve un tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n      x\n  <dbl>\n1     1\n2     2\n3     3\n```\n\n\n:::\n\n```{.r .cell-code}\ntb$x    # Devuelve un vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n## `data.frame` vs. `tibble`\n\nEn resumen, ambas estructuras tienen sus fortalezas. Mientras que el `data.frame` es simple y adecuado para scripts básicos, el `tibble` destaca por su consistencia y facilidad de integración con el tidyverse, haciéndolo ideal para análisis más complejos.\n\n### Generar `tibble`\n\nUn `tibble` puede crearse desde un `data.frame` o directamente desde cero. A continuación, mostramos algunos ejemplos.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndft <- as_tibble(df)\ndft\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n      x y    \n  <dbl> <chr>\n1     1 A    \n2     2 B    \n3     3 C    \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narboles <- tibble(\n  especie = c(\"Pinus halepensis\", \"Quercus ilex\", \"Quercus ilex\", \n              \"Pinus pinaster\", \"Quercus pyrenaica\"),\n  altura_m = c(15, 8, 10, 12, 18),\n  dbh_cm = c(30, 40, 35, 25, 45),\n  site = c(\"plot_A\", \"plot_B\", \"plot_C\", \"plot_A\", \"plot_B\")\n)\n\narboles \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  especie           altura_m dbh_cm site  \n  <chr>                <dbl>  <dbl> <chr> \n1 Pinus halepensis        15     30 plot_A\n2 Quercus ilex             8     40 plot_B\n3 Quercus ilex            10     35 plot_C\n4 Pinus pinaster          12     25 plot_A\n5 Quercus pyrenaica       18     45 plot_B\n```\n\n\n:::\n:::\n\n\n\nCrear un tibble transpuesto:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narboles <- tribble(\n  ~especie,            ~altura_m, ~dbh_cm, ~site,\n  \"Pinus halepensis\",   15,        30,      \"plot_A\",\n  \"Quercus ilex\",       8,         40,      \"plot_B\",\n  \"Quercus ilex\",       10,        35,      \"plot_C\",\n  \"Pinus pinaster\",     12,        25,      \"plot_A\",\n  \"Quercus pyrenaica\",  18,        45,      \"plot_B\"\n)\narboles \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  especie           altura_m dbh_cm site  \n  <chr>                <dbl>  <dbl> <chr> \n1 Pinus halepensis        15     30 plot_A\n2 Quercus ilex             8     40 plot_B\n3 Quercus ilex            10     35 plot_C\n4 Pinus pinaster          12     25 plot_A\n5 Quercus pyrenaica       18     45 plot_B\n```\n\n\n:::\n:::\n\n\n\nTambién es posible crear un `tibble` a partir de estructuras más complejas, como listas. Esto es particularmente útil para organizar datos jerárquicos o anidados.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlista_compleja <- list(\n  numeros = c(1, 2, 3),\n  letras = c(\"A\", \"B\", \"C\"),\n  datos = list(\n    tipo = c(\"x\", \"y\", \"z\"),\n    valores = c(10, 20, 30)\n  )\n)\n\nlc <- enframe(lista_compleja)\nlc \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name    value           \n  <chr>   <list>          \n1 numeros <dbl [3]>       \n2 letras  <chr [3]>       \n3 datos   <named list [2]>\n```\n\n\n:::\n:::\n\n\n\n## Conclusión\n\nEl uso de `data.frame` y `tibble` depende de las necesidades específicas del análisis. Mientras que `data.frame` ofrece un enfoque tradicional y sencillo, `tibble` proporciona herramientas modernas y flexibles, integrándose perfectamente en el entorno del tidyverse. Al dominar estas estructuras, podrás manejar datos de manera más eficiente y efectiva.\n\n---\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}