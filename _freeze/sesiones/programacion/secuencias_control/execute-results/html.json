{
  "hash": "f4a4db19869306d689ae1fce6204f387",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Estructuras de Control en Programación\"\nsubtitle: \"(ejemplos con R)\"\nauthor: \n  - name: \"Antonio J. Pérez-Luque\"\n    orcid: 0000-0002-1747-0469\n    email: antonio.perez@inia.csic.es\n    affiliation: Instituto de Ciencias Forestales (CIFOR) | INIA-CSIC (Madrid)\ndate: 2025-01-15\nsesion: 3\nformat: \n  revealjs:\n    auto-stretch: false \n    logo: \"images/logo-ugr.png\"\n    footer: Master Universitario en Conservación, Gestión y Restauración de la Biodiversidad\n    theme: [default, \"../../custom_theme.scss\"] \n    transition: fade\n    background-transition: fade\n    highlight-style: a11y\ncode-link: true\ncrossref:\n  fig-title: Figura     # (default is \"Figure\")\n  tbl-title: Tabla     # (default is \"Table\")\n  title-delim: .     # (default is \":\")\n  fig-prefix: Figura\n  tbl-prefix: Tabla\n  ref-hyperlink: true\n  sec-prefix: \"\"\n  sec-labels: alpha\ncode-annotations: hover\nexecute:\n  echo: true     \n  eval: true     \n  output: true   \n  include: true\n---\n\n\n\n## Introducción\n\n- **Estructuras de control**: Herramientas fundamentales en programación que permiten modificar el flujo de ejecución de un programa según ciertas condiciones o repeticiones.\n- Son esenciales para tomar decisiones dinámicas, realizar acciones repetitivas y dirigir cómo se ejecuta el código, haciéndolo más flexible y adaptable.\n\n---\n\n## Tipos de Estructuras de Control {footer=false}\n\n::: {.incremental}\n\n::: small\n1. **Estructuras Secuenciales**: Ejecutan instrucciones una tras otra\n\n2. **Estructuras de Selección** (Condicionales): Permiten que un bloque de código se ejecute o no, en función de una condición. Dependiendo de si una condición es `TRUE` o `FALSE`, el algoritmo toma un camino u otro. **Tipos**:\n     - **Simple**: Una única condición (**`if`**).\n     - **Doble**: Incluye una alternativa (**`if-else`**).\n     - **Múltiple**: Varias alternativas posibles (**`switch`**).\n\n3. **Estructuras de Iteración** (Bucles): Permiten repetir un bloque de código varias veces mientras se cumpla una condición o sobre una secuencia de elementos. **Tipos**:\n     - **`for`**: Itera sobre una secuencia conocida.\n     - **`while`**: Repite mientras una condición sea `TRUE`.\n     - **`repeat`**: Ejecuta indefinidamente hasta que se use un `break` para detenerlo.\n::: \n\n::: \n\n--- \n\n### 2. Condicionales **simple** \n\n::: small\n- Permiten que un bloque de código se ejecute o no, en función de una condición. \n- Dependiendo de si una condición es `TRUE` o `FALSE`, el algoritmo toma un camino u otro.\n\n\n::: {.callout-tip}\n## Recuerda los operadores en R:\n- `==` (igualdad)\n- `!=` (distinto)\n- `>` (mayor que)\n- `<` (menor que)\n- `>=` (mayor o igual que)\n- `<=` (menor o igual que)\n\n::: \n\n::: \n\n---\n\n\n### 2. Condicionales **simples** \n\n::: small\n\n- Datos ejemplo\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\n\npinos <- tibble(\n  id = 1:10,\n  especie = c(\n    \"sylvestris\", \"nigra\", \"pinaster\",\n    \"sylvestris\", \"nigra\", \"pinaster\",\n    \"sylvestris\", \"nigra\", \"pinaster\", \"sylvestris\"\n  ),\n  dbh_cm = c(\n    30.5, 6.5, 7.2, 5.0, 28.3,\n    35.1, 7.0, 6.8, 40.0, 32.7\n  ),\n  altura_m = c(\n    12.5, 13.2, 10.0, 9.5, 14.0,\n    15.0, 8.2, 11.8, 14.5, 12.0\n  )\n)\n```\n:::\n\n\n::: \n\n---\n\n### 2. Condicionales **simples** \n\n\n::: small\n\n::: {.panel-tabset}\n\n## `if`\n\n\n::: {.cell}\n\n```{.r .cell-code}\narbol <- pinos[1, ]\n\nif (arbol$dbh_cm > 7.5) {\n  print(paste(\n    \"El arbol ID =\", arbol$id,\n    \" es un adulto, y tiene un diámetro de \", arbol$dbh_cm, \" cm\"\n  ))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"El arbol ID = 1  es un adulto, y tiene un diámetro de  30.5  cm\"\n```\n\n\n:::\n:::\n\n\n\n\n## `ifelse`\n\n\n::: {.cell}\n\n```{.r .cell-code}\narbol <- pinos[2, ]\n\nif (arbol$dbh_cm > 7.5) {\n  print(paste(\"El arbol ID =\", arbol$id,\n    \"es un adulto, y tiene un diámetro de\", arbol$dbh_cm, \" cm\",\n    sep = \" \"\n  ))\n} else {\n  print(\n    paste(\n      \"El arbol ID =\", arbol$id,\n      \"es un juvenil, y tiene un diámetro de\", arbol$dbh_cm, \" cm\"\n    ),\n    sep = \" \"\n  )\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"El arbol ID = 2 es un juvenil, y tiene un diámetro de 6.5  cm\"\n```\n\n\n:::\n:::\n\n\n\n\n## `switch`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp <- \"sylvestris\" \n\nswitch (sp,\n  \"nigra\" = {\n    n <- nrow(subset(pinos, especie == sp))\n    paste(\"Existen\", n, \"individuos de P.\", sp)\n  },\n  \"sylvestris\" = {\n    n <- nrow(subset(pinos, especie == sp))\n    paste(\"Existen\", n, \"individuos de P.\", sp)\n  },\n  \"pinaster\" = {\n    n <- nrow(subset(pinos, especie == sp))\n    paste(\"Existen\", n, \"individuos de P.\", sp)\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Existen 4 individuos de P. sylvestris\"\n```\n\n\n:::\n:::\n\n\n\n\n## `if` (otro ejemplo)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npino1 <- pinos[1, ]\n\nif (pino1$dbh_cm > 7.5) {\n  # calcula el área basal del pino en m2\n  area_basal <- pi * ((pino1$dbh_cm / 100) / 2)^2\n\n  print(paste(\n    \"El árbol con ID\", pino1$id,\n    \"pertenece a la especie Pinus\", pino1$especie,\n    \"y tiene un área basal de\",\n    round(area_basal, 4), \"m².\", sep = \" \"\n  ))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"El árbol con ID 1 pertenece a la especie Pinus sylvestris y tiene un área basal de 0.0731 m².\"\n```\n\n\n:::\n:::\n\n\n\n::: \n\n::: \n\n## Ejemplo práctico \n::: small\n- Se han muestreando diferentes *plots circulares* en pinares de repoblación para evaluar la densidad de plantación\n- En cada plot (de radio variable) anotamos el número de individuos de cada especie \n- ¿podrías escribir un código que calcule el área muestreada en cada plot?\n\n::: {.panel-tabset}\n### Creación de un `tibble` con los datos \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\npinares <- tibble(\n  id_plot = c(\"syl1\", \"syl2\", \"nig1\", \"nig2\", \"nig3\"),\n  radio_m = c(5, 6, 7, 8, 9),\n  n_individuos = c(10, 12, 15, 18, 20)\n)\n```\n:::\n\n\n### Vista del tibble\n\n\n::: {.cell}\n\n```{.r .cell-code}\npinares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  id_plot radio_m n_individuos\n  <chr>     <dbl>        <dbl>\n1 syl1          5           10\n2 syl2          6           12\n3 nig1          7           15\n4 nig2          8           18\n5 nig3          9           20\n```\n\n\n:::\n:::\n\n\n\n::: \n:::\n\n## Solucionario \n\n::: {.notes}\nSol1. generar objetos para cada radio. Inconvenientes: código repetitivo y poco eficiente. Facilidad de cometer errores.\nSol2. Crear una nueva columna en el tibble con el área de cada plot. Más eficiente y menos propenso a errores.\nSol3. Crear una función que calcule el área de un plot y aplicarla a cada radio. Más eficiente y reutilizable.\n:::\n\n::: small\n::: {.panel-tabset}\n### Sol. 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nradios <- pinares$radio_m\n\narea1 <- pi * radios[1]^2\nprint(area1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 78.53982\n```\n\n\n:::\n\n```{.r .cell-code}\narea2 <- pi * radios[2]^2\nprint(area2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 113.0973\n```\n\n\n:::\n\n```{.r .cell-code}\narea3 <- pi * radios[3]^2\nprint(area3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 153.938\n```\n\n\n:::\n\n```{.r .cell-code}\narea4 <- pi * radios[4]^2\nprint(area4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 201.0619\n```\n\n\n:::\n\n```{.r .cell-code}\narea5 <- pi * radios[5]^2\nprint(area5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 254.469\n```\n\n\n:::\n:::\n\n\n\n### Sol. 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\npinares$area_m2 <- pi * pinares$radio_m^2\n\npinares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  id_plot radio_m n_individuos area_m2\n  <chr>     <dbl>        <dbl>   <dbl>\n1 syl1          5           10    78.5\n2 syl2          6           12   113. \n3 nig1          7           15   154. \n4 nig2          8           18   201. \n5 nig3          9           20   254. \n```\n\n\n:::\n:::\n\n\n\n\n### Sol. 3 \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcula_area <- function(x) {\n  return(pi * x^2)\n}\n\npinares$area2_m2 <- sapply(pinares$radio_m, calcula_area)\npinares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  id_plot radio_m n_individuos area_m2 area2_m2\n  <chr>     <dbl>        <dbl>   <dbl>    <dbl>\n1 syl1          5           10    78.5     78.5\n2 syl2          6           12   113.     113. \n3 nig1          7           15   154.     154. \n4 nig2          8           18   201.     201. \n5 nig3          9           20   254.     254. \n```\n\n\n:::\n:::\n\n\n\n### Bucles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in pinares$radio_m) {\n  print(pi * i^2)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 78.53982\n[1] 113.0973\n[1] 153.938\n[1] 201.0619\n[1] 254.469\n```\n\n\n:::\n:::\n\n\n::: \n:::\n\n--- \n\n## 3. Estructuras de iteración (bucles) \n\n- Son secuencias código que se ejecutan repetidas veces, hasta que la condición asignada a dicho bucle deja de cumplirse\n\n**¿Por qué usarlos?**\n\n  - Para iterar sobre elementos de un conjunto de datos.\n  - Para automatizar tareas repetitivas.\n  - Para realizar cálculos iterativos.\n  \n---\n  \n## **Tipos de bucles**:\n  - **`for`**: Iteraciones sobre elementos definidos.\n  - **`while`**: Iteraciones controladas por una condición.\n  - **`repeat`**: Repeticiones indefinidas con una interrupción explícita.\n\n\n## **`for` loop: iteraciones determinadas**\nEjecuta un bloque de código para cada elemento de una secuencia predefinida.\n\n\n<span style=\"color:blue;\">for (</span><span style=\"color:red;\">item</span> in <span style=\"color:orange;\">list_of_items</span><span style=\"color:blue;\">)</span> <span style=\"color:blue;\">{</span> <br>\n  <p style=\"text-indent: 50px;\">\n  <span style=\"color:green;\">do_something(</span><span style=\"color:red;\">item</span><span style=\"color:green;\">)</span></p>\n<span style=\"color:blue;\">}</span>\n\n\n\n#### **Ejemplo**:\n\n::: {.panel-tabset}\n## R\n\n```{.r}\nfor (i in 1:5) {\n  print(i * i)\n}\n```\n\n## Python\n\n```{.python}\nfor i in range(1, 6):\n    print(i**2)\n```\n\n:::\n\n---\n\n### Estudio en detalle del bucle \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nradios <- pinares$radio_m\nradios\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6 7 8 9\n```\n\n\n:::\n:::\n\n\n\n<br> \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in radios) { # <1>\n  area <- (pi * i^2) # <2>\n  print(area) # <2>\n} # <3>\n```\n:::\n\n\n\n1. **Iteración**: `i` toma el valor de cada elemento de la lista `radios`.\n2. **Ejecución del código**: Se calcula el área de cada plot y se imprime por pantalla\n3. **Finalización**: Si hay mas elementos dentro de la lista, el bucle se repite. Cuando se haya procesado todos los elementos, el bucle termina\n\n<br> \n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 78.53982\n[1] 113.0973\n[1] 153.938\n[1] 201.0619\n[1] 254.469\n```\n\n\n:::\n:::\n\n\n\n## Elementos del bucle\n\n![](images/for_structure.png){fig-align=\"center\" width=70%}\n\n\n## Elementos del bucle: **Índice** \n\n::: small\nLooping por **valor**: cuando se itera sobre un valor directamente\n\n  - Más compacto y legible\n  - Directamente trabaja con los valores del vector\n  - Útil cuando no necesitas los índices, solo los valores\n\n::: \n\n```{.r}\nfor (i in radios) {\n  area <- pi * i^2\n  print(area)\n}\n```\n\n--- \n\n## Elementos del bucle: **Índice** {footer=false}\n\n::: small\nLooping por **índice**: cuando se itera sobre un índice de la lista o del vector \n\n  - Más flexible y versátil\n  - Permite acceder tanto a los índices como a los valores\n  - Útil cuando necesitas los índices para realizar operaciones específicas\n\n::: \n\n::: {.panel-tabset}\n#### Ejemplo 1\n```{.r}\nfor (i in 1:5) {\n  area <- pi * radios[i]^2\n  print(area)\n}\n```\n\n#### Ejemplo 2\n```{.r}\nfor (i in 1:length(radios)) {\n  area <- pi * radios[i]^2\n  print(area)\n}\n```\n:::\n\n---\n\n### ¿looping por índice o por valor?\n\n::: small\n\n- El resultado es el mismo, pero el enfoque depende de la tarea que estés realizando\n- El bucle por índice permite realizar operaciones más complejas y personalizadas\n- Permite almacenar los datos calculados en el bucle \n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nareas1 <- vector() # <1>\n\nareas2 <- vector(mode = \"numeric\", length = length(radios)) # <2>\n```\n:::\n\n\n\n1. Podemos crear un vector vacío y almacenar los resultados en cada iteración\n2. Crear un vector vacío tipo numérico con la longitud de la lista `radios` \n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(areas1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(areas2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\n--- \n\n### ¿looping por índice o por valor?\n\n\n::: {.panel-tabset}\n### areas1\n```{.r}\nareas1 <- vector()\n  \nfor (i in 1:length(radios)) {\n  area <- pi * radios[i]^2\n  # print(area)\n  areas1[i] <- area \n}\n  \nprint(areas1)\n```\n\n\n### areas2\n```{.r}\nareas2 <- vector(mode = \"numeric\", length = length(radios))\n  \nfor (i in 1:length(radios)) {\n  area <- pi * radios[i]^2\n  # print(area)\n  areas2[i] <- area \n}\n\nprint(areas2)\n```\n\n::: \n\n## Práctica 1\n\nEscribe un bucle que permita calcular el tamaño de los plots de las zonas de muestreo en hectáreas\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nareas_ha <- vector(mode = \"numeric\", length = length(radios))\n  \nfor (i in 1:length(radios)) {\n  area <- pi * radios[i]^2\n  area_ha <- area / 10000\n  areas_ha[i] <- area_ha\n}\n\nprint(areas_ha)\n```\n:::\n\n\n\n## Práctica 2\nCompleta el siguiente bucle para que imprima los nombres de las especies de los pinares\n\n\n```{.r}\nespecies <- c(\n  \"Pinus sylvestris\", \"Pinus nigra\", \"Pinus halepensis\",\n  \"Pinus pinaster\", \"Pinus canariensis\", \"Pinus pinea\"\n)\n\nfor (sp in 1:length( <-???-> )) { \n  print(especies[ <-???-> ])     \n}\n```\n\n## Práctica 3 {footer=false}\n\n::: small\n\nEscribe un bucle que calcule la **densidad de árboles** para cada parcela en pies/hectárea\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nradios <- pinares$radio_m # <1>\narboles <- pinares$n_individuos # <1>\n\ndensidad <- vector(\n  mode = \"numeric\",\n  length = length(pinares$radio_m)) # <2>\n\nfor (i in 1:length(radios)) {\n  area <- pi * radios[i]^2 # <3>\n  area_ha <- area / 10000 # <3>\n\n  densidad[i] <- arboles[i] / area_ha # <4>\n}\n```\n:::\n\n\n\n\n1. Dos vectores de datos\n2. Objeto donde almacenar los resultados\n3. Itera sobre el primer vector (`radios`) para calcular el área\n4. Itera sobre el seguno vector (`arboles`) para calcular la densidad\n\n\n::: {.notes}\nEsta práctia sirve para introducir concepto de bucle con entrada de diferentes fuentes. Usando index, podemos acceder a diferentes entradas.\n::: \n\n\n## Práctica 3 {footer=false}\n\n::: small\n\n* ¿Podría actuar sobre un solo `data.frame` o `tibble`?\n* ¿Podría almacenar los resultados en ese mismo `tibble`? \n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npinares <- tibble( \n  id_plot = c(\"syl1\", \"syl2\", \"nig1\", \"nig2\", \"nig3\"),\n  radio_m = c(5, 6, 7, 8, 9),\n  n_individuos = c(10, 12, 15, 18, 20)\n)\n  \nfor (i in 1:nrow(pinares)) {\n  pinares$area[i] <- (pi * pinares$radio_m[i]^2 / 10000)\n  pinares$densidad[i] <- pinares$n_individuos[i] / pinares$area[i] \n}\n\npinares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  id_plot radio_m n_individuos    area densidad\n  <chr>     <dbl>        <dbl>   <dbl>    <dbl>\n1 syl1          5           10 0.00785    1273.\n2 syl2          6           12 0.0113     1061.\n3 nig1          7           15 0.0154      974.\n4 nig2          8           18 0.0201      895.\n5 nig3          9           20 0.0254      786.\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.notes}\nEsta práctia sirve para introducir concepto de bucle con entrada de diferentes fuentes. Usando index, podemos acceder a diferentes entradas.\n::: \n\n## Aplicaciones\n\n- looping en funciones\n- looping sobre dataframes o tibbles ()\n- Looping sobre archivos y directorios\n- Almacenar datos \n- Bucles anidados \n\n\n## **`while` Loop: Repetición Condicional**\nEjecuta un bloque de código mientras una condición sea verdadera\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nradios <- pinares$radio_m \n\ni <- 1 # <1> \n  \nwhile (i <= 3) { # <2> \n  \n  area <- pi * radios[i]^2 # <3>\n  area_ha <- area / 10000  # <3>\n  print(area_ha) # <3>\n  \n  i <- i + 1 # <4>\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.007853982\n[1] 0.01130973\n[1] 0.0153938\n```\n\n\n:::\n:::\n\n\n\n1. Iniciamos el contador\n2. Condición de salida\n3. Código a ejecutar\n4. Actualización del contador \n\n---\n\n::: {.callout-important}\n## Inicializar las varbiables\n::: \n\n::: small\n\n::: {.panel-tabset}\n\n## Dataframe \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbosques <- tibble( \n  id_plot = c(\"syl1\", \"syl2\", \"nig1\", \"nig2\", \"nig3\"),\n  radio_m = c(5, 6, 7, 8, 9),\n  n_individuos = c(10, 12, 15, 18, 20)\n)\n```\n:::\n\n\n\n## Sin inicializar\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1 \nwhile (i <= 3) {\n  bosques$area[i] <- (pi * bosques$radio_m[i]^2 / 10000)\n  bosques$densidad[i] <- bosques$n_individuos[i] / bosques$area[i]\n  i <- i + 1\n}\n\nbosques\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  id_plot radio_m n_individuos    area densidad\n  <chr>     <dbl>        <dbl>   <dbl>    <dbl>\n1 syl1          5           10 0.00785    1273.\n2 syl2          6           12 0.0113     1061.\n3 nig1          7           15 0.0154      974.\n4 nig2          8           18 0.00785    1273.\n5 nig3          9           20 0.00785    1273.\n```\n\n\n:::\n:::\n\n\n\n## Inicializadas\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbosques$area <- vector(mode = \"numeric\", length = nrow(bosques)) \nbosques$densidad <- vector(mode = \"numeric\", length = nrow(bosques))\n\ni <- 1 \nwhile (i <= 3) {\n  bosques$area[i] <- (pi * bosques$radio_m[i]^2 / 10000)\n  bosques$densidad[i] <- bosques$n_individuos[i] / bosques$area[i]\n  i <- i + 1\n}\n\nbosques\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  id_plot radio_m n_individuos    area densidad\n  <chr>     <dbl>        <dbl>   <dbl>    <dbl>\n1 syl1          5           10 0.00785    1273.\n2 syl2          6           12 0.0113     1061.\n3 nig1          7           15 0.0154      974.\n4 nig2          8           18 0             0 \n5 nig3          9           20 0             0 \n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: \n\n## `repeat` Loop: Repetición Indefinida\n\n::: small\n\n- Ejecuta un bloque de código indefinidamente hasta que se usa `break`.\n\n**Ejemplo**: obtener el dbh medio de los 5 individuos mas grandes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npinos_ordenados <- pinos[order(pinos$dbh_cm, decreasing = TRUE), ]\n\ni <- 1 # contador\npromedio <- 0 # variable donde guardar \n  \nrepeat { \n  # promedio parcial (usando los primeros i pinos más grandes)\n  promedio <- mean(pinos_ordenados$dbh_cm[1:i])\n  \n  # Verificar si hemos procesado más de 5 pinos\n  if (i > 5) {\n    print(paste(\"Promedio de dbh_cm de los 5 pinos más grandes:\", promedio))\n    break\n  }\n  # Avanzar al siguiente pino\n  i <- i + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Promedio de dbh_cm de los 5 pinos más grandes: 28.9666666666667\"\n```\n\n\n:::\n:::\n\n\n\n::: \n\n--- \n\n**Alternativas Vectorizadas (apply, sapply, tapply)**\n\n::: small \n\n- Herramientas para aplicar funciones a estructuras de datos, pero cada una tiene su uso específico dependiendo de la estructura y el tipo de operación deseada. \n\n- `apply`: aplica una función a las filas o columnas de una matriz o array.\n- `sapply`: aplica una función a cada elemento de una lista o vector y simplifica automáticamente la salida al formato más compacto posible (vector, matriz o lista).\n- `tapply`: aplica una función a los subconjuntos de un vector, definidos por un factor o factores.\n\n::: \n\n--- \n\n**Alternativas Vectorizadas (apply, sapply, tapply)**\n\n::: small\n\n::: {.panel-tabset}\n### `apply`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcular media de cada columna numérica\nd <- as.matrix(pinos[, c(\"dbh_cm\", \"altura_m\")])\n  \napply(d, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  dbh_cm altura_m \n   19.91    12.07 \n```\n\n\n:::\n:::\n\n\n\n### `sapply`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identificar columnas numéricas\nsapply(pinos, is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      id  especie   dbh_cm altura_m \n    TRUE    FALSE     TRUE     TRUE \n```\n\n\n:::\n:::\n\n\n\n### `tapply`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Promedio de dbh por especie \ntapply(pinos$dbh_cm, pinos$especie, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     nigra   pinaster sylvestris \n  13.86667   27.43333   18.80000 \n```\n\n\n:::\n:::\n\n\n\n::: \n\n**Ventajas**:\n\n- Más rápidas y concisas que los bucles tradicionales.\n- Mejor adaptadas para trabajar con grandes volúmenes de datos.\n\n::: \n\n---\n\n## **`purrr`**\n\n::: small\n\n**¿Qué es `purrr`?**\n\n- `purrr` es un paquete del ecosistema tidyverse que facilita la programación funcional.\n\n**Ejemplo Comparativo**\n\n::: {.panel-tabset}\n\n### for\n\n\n::: {.cell}\n\n```{.r .cell-code}\nareas_ha <- vector(mode = \"numeric\", length = length(radios))\n  \nfor (i in 1:length(radios)) {\n  area <- pi * radios[i]^2\n  area_ha <- area / 10000\n  areas_ha[i] <- area_ha\n}\n\nareas_ha\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.007853982 0.011309734 0.015393804 0.020106193 0.025446900\n```\n\n\n:::\n:::\n\n\n\n### purrr \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nareas_ha <- map_dbl(radios, ~ pi * (.x^2) / 10000)\nareas_ha\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.007853982 0.011309734 0.015393804 0.020106193 0.025446900\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::\n\n--- \n\n## **`purrr`**\n\n::: small \n\n**Ventajas de `purrr`**:\n\n- Sintaxis más compacta y legible.\n- Integración directa con otras herramientas del tidyverse.\n- Mejora la eficiencia para operaciones funcionales repetitivas.\n\n:::\n\n---\n\n## **Comparación General**\n\n::: small\n\n| Tipo de Bucle     | Ventajas                          | Desventajas                       |\n|--------------------|-----------------------------------|------------------------------------|\n| `for`             | Simple y flexible                 | Menos eficiente con grandes datos |\n| `while`           | Útil para condiciones dinámicas   | Mayor riesgo de bucles infinitos  |\n| `repeat`          | Gran control manual               | Requiere interrupción explícita   |\n| `apply`/`tapply`  | Altamente eficiente y compacto    | Menos intuitivo para principiantes|\n| `purrr::map`      | Sintaxis legible y funcional      | Requiere instalación adicional    |\n\n\n::: \n\n---\n\n## **Conclusión**\n\n- **Básico**: Los bucles (`for`, `while`, `repeat`) son fundamentales para aprender programación iterativa.\n- **Avanzado**: Las funciones vectorizadas (`apply`, `tapply`) y paquetes como `purrr` son ideales para mejorar el rendimiento y la legibilidad.\n- **Recomendación**: Usa bucles simples para aprender y alterna con soluciones vectorizadas o funcionales para proyectos más complejos.\n\n\n## ¿Alguna duda?\n\n- {{< fa brands bluesky >}} [ajpelu.bsky.social](https://bsky.app/profile/ajpelu.bsky.social)\n- [antonio.perez@inia.csic.es](mailto: antonio.perez@inia.csic.es)\n\n\n<small>Ayuda JDC2022-050056-I financiada por MCIN/AEI /10.13039/501100011033 y por la Unión Europea NextGenerationEU/PRTR</small>\n\n![](images/logo-jdc.png){fig-align=\"center\" width=40%}\n\n\n::: {.callout-tip}\n## Si usas esta presentación puedes citarla como:\n<small>**Pérez-Luque, A.J. **(2025). Estructuras de Control en Programación (ejemplos con R). Material Docente de la Asignatura: Ciclo de Gestión de los Datos. Master Universitario en Conservación, Gestión y Restauración de la Biodiversidad. Universidad de Granada. [https://ecoinfugr.github.io/ecoinformatica/](https://ecoinfugr.github.io/ecoinformatica/) </small>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}