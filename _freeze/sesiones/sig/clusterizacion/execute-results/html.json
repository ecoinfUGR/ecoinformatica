{
  "hash": "b8be0c66d8d3621f70520b4ece8c0c31",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Clusterización de variables ambientales\"\nauthor: \n  - name: \"María Suárez Muñoz\"\n    orcid: 0000-0003-1765-6885\n    email: maria.suarez.munoz@gmail.com\n    affiliation: Departamento de Ingeniería Forestal, Universidad de Córdoba\ndate: 2025-01-07\nsesion: 1\nformat: \n  revealjs:\n    auto-stretch: false \n    logo: \"images/logo-ugr.png\"\n    footer: Master Universitario en Conservación, Gestión y Restauración de la Biodiversidad\n    theme: [default, \"../../custom_theme.scss\"] \n    transition: fade\n    background-transition: fade\n    highlight-style: a11y\ncode-link: true\ncrossref:\n  fig-title: Figura     # (default is \"Figure\")\n  tbl-title: Tabla     # (default is \"Table\")\n  title-delim: .     # (default is \":\")\n  fig-prefix: Figura\n  tbl-prefix: Tabla\n  ref-hyperlink: true\n  sec-prefix: \"\"\n  sec-labels: alpha\n---\n\n\n\n# Introducción {.unnumbered}\n\nLa evaluación y planificación de actuaciones de un área afectada por un incendio forestal puede requerir la integración de multitud de variables en una extensión amplia del territorio. La mera observación de múltiples capas de información puede no ser suficiente a la hora de tomar decisiones. Por ello, es habitual realizar análisis de la información que nos permitan combinarla de alguna manera. Esta combinación puede hacerse de distintas maneras, desde técnicas estadísticas a análisis multicriterio, dependiendo de las fuentes de información que consideremos y el objetivo planteado. En esta sesión exploraremos una de estas opciones, la creación de áreas homogéneas mediante clusterización.\n\n# Creación de áreas homogéneas mediante clusterización\n\nLa creación de mapas de áreas homogéneas en virtud de distintas variables ambientales es una técnica muy utilizada para planificar actuaciones en el territorio. Esto es especialmente relevante en zonas muy extensas que no pueden ser manejadas sólo aplicando el conocimiento experto. \n\nLa idea clave de estas áreas homogéneas es que, con su creación, disponemos de una espacialización de ciertas variables, que reflejamos en un mapa. En lugar de contemplar el mundo con toda su complejidad, lo vemos sólo con la visión de las variables que hemos definido para generar dicho mapa. Es decir, podemos “leer” el territorio usando esas variables. \nPor ejemplo, en una zona quemada, en lugar de tener un gradiente continuo de multitud de variables descriptoras (capacidad de regeneración, profundidad del suelo, etc.) tendremos una diferenciación en zonas con características acotadas, como podrían ser “lugares con suelos poco profundos y alta insolación”. De esta forma podemos plantear actuaciones de manejo particularizadas a cada unidad homogénea.\n\n## Selección de variables\n\nPara la creación del mapa de áreas homogéneas en primer lugar necesitaremos definir qué variables consideramos relevantes para nuestro objetivo. Una vez definidas estas variables podremos combinarlas para generar el mapa. Es habitual que tengamos que repetir el proceso varias veces, iterando sobre distintos conjuntos de variables hasta que demos con una combinación que nos satisfaga. \n\n¿Qué variables crees que pueden ser útiles para nuestro caso de uso?\n\n## Clusterización\n\nEn esta práctica aplicaremos una clusterización basada en el algoritmo k-means. Para ello trabajaremos desde `R` con las capas que hemos generado durante las prácticas con `qGIS`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### CONFIGURACIÓN\n# Instalación y carga de paquetes\n# install.packages(\"RStoolbox\")\nlibrary(RStoolbox)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis is version 1.0.0 of RStoolbox\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(raster)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: sp\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nterra 1.7.78\n```\n\n\n:::\n\n```{.r .cell-code}\n# Opciones de configuración\ndate <- \"20250207\"\n\npath <- \"/Users/maria.suarez.munoz/Library/CloudStorage/GoogleDrive-msuamun@go.ugr.es/My Drive/Docencia/Ecoinformatica_UGR/2024_2025/SIG_qGIS/\"\n\n# Cargar máscara de la zona a clusterizar\n# mask <- raster(paste0(path, \"mask.tif\")) # Máscara creada con qGIS\n\n# Explorar capa\n# mask\n# plot(mask)\n\n# Cargar capas con las que vamos a trabajar: incidencia/orientación, aridez, temperaturas, precipitaciones\n# capa1 <- raster(paste0(path, \"....tif\"))\n# capa2 <- raster(paste0(path, \"....tif\"))\n# ...\n\n# Apilar capas: la función \"stack\" del paquete raster crea una pila de rásters proveniente de distintos archivos. El algoritmo k-means requiere que todas las capas \"encajen\" entre sí, por lo que necesitaremos apilarlas en un stack\n# my_stack <- stack(...)  \n```\n:::\n\n\n\nHasta ahora hemos trabajado en `qGIS` con capas que tenían distintos sistemas de referencia y distintas resoluciones, sin haber tenido problemas por ello. `qGIS` proyecta al vuelo las capas que no están en el mismo sistema de referencia que nuestro proyecto, aunque como dijimos es más adecuado reproyectar las capas para asegurarnos de que todos los cálculos se hacen correctamente. `R`, sin embargo, no hace casi nada \"under the hood\", sino que nos avisa cuando algo da problemas. Vamos a explorar las capas para ver qué pasa\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Explorar capas\n# capa1\n# capa2\n# ...\n```\n:::\n\n\n\nAl explorar las capas vemos que éstas tienen distintas propiedades. No todas están en el mismo sistema de referencia ni tienen la misma resolución, por lo que necesitamos *alinearlas*. Dos capas ráster están alineadas cuando están en el mismo sistema de referencia y tienen la misma resolución y el mismo origen. Es decir, que encajan en todos los aspectos. Por tanto, tendremos que *reproyectar* y *remuestrear* las capas que no encajan entre sí.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reproyectar\n# capa1_23030 <- project(capa1, mask)\n# ...\n\n# Resamplear: generar nueva capa con la resolución deseada\n# capa1_resampled <- resample(capa1_23030, mask, method = \"bilinear\")\n```\n:::\n\n\n\nImportante: prestar atención al método utilizado en el remuestreado, el método más adecuado dependerá de la naturaleza de nuestra variable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enmascarar\n# capa1_masked <- capa1_resampled * mask\n\n# Apilar capas\n# my_stack <- stack(...)  \n# names(my_stack) <- c(\"...\")\n# plot(my_stack)\n\n# Crear brick: La función \"brick\" requiere que todas las capas provengan del mismo objeto (por ejemplo, un conjunto de bandas espectrales o capas que ya estén apiladas en un stack)\n# my_brick <- brick(my_stack) # Necesario??\n```\n:::\n\n\n\nUna vez construida nuestra pila de variables tenemos que decidir cuántas áreas son adecuadas. ...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ...\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Run example unsupervised classifications with different algorithms\n# Función que utilizamos: unsuperClass del paquete RStoolbox\n\n# Following N. Aquilue scripts\n# Notes: https://www.mailman.columbia.edu/research/population-health-methods/cluster-analysis-using-k-means\n# set.seed(25) # Definir semilla para los procesos aleatorios\n# nClass <- 7\n\n# Hartigan-Wong kmeans algorithm\n# algorithm <- \"Hartigan-Wong\"\n# classHW <- unsuperClass(my_brick, nClasses=nClass, nStarts=nClass*4, nIter=2000, norm=T, clusterMap=F, algorithm = algorithm) # If Warning: \"Quick-TRANSfer stage steps exceeded maximum\", better other algorithm\n# plot(classHW$map)\n# classHW; t.classHW <- table(classHW$map[]); t.classHW\n\n# Lloyd kmeans algorithm\n# algorithm <- \"Lloyd\"\n# classLL <- unsuperClass(my_brick, nClasses=nClass, nStarts=nClass*4, nIter=2000, norm=T, clusterMap=F, algorithm = algorithm)\n# plot(classLL$map)\n# classLL; t.classLL <- table(classLL$map[]); t.classLL\n\n# MacQueen kmeans algorithm\n# algorithm <- \"MacQueen\"\n# classMQ <- unsuperClass(my_brick, nClasses=nClass, nStarts=nClass*4, nIter=2000, norm=T, clusterMap=F, algorithm = algorithm)\n# plot(classMQ$map)\n# classMQ; t.classMQ <- table(classMQ$map[]); t.classMQ\n\n# Differences among algorithms? Choose appropriate one:\nalgorithm <- \"MacQueen\"\n\n## Choose appropriate number of classes\n# wss <- 0 # Initialize total within sum of squares error: wss\n# for (i in 1:10) { # Look over 1 to 10 possible clusters\n#   out <- unsuperClass(my_brick, nClasses=i, nStarts=i*4, nIter = 2000, norm=T, clusterMap=F, algorithm = algorithm)\n#   wss[i] <- out$model$tot.withinss # Save the within cluster sum of squares\n# }\n# plot(1:10, wss, type = \"b\", xlab = \"Number of Clusters\", ylab = \"Within groups sum of squares\")\n\n## Run and export clustering for optimal number of classes\n## ** TO BE DEFINE BASED ON PREVIOUS PLOT **\noptimal_nclasses <- 4\n\n# clust <- unsuperClass(my_brick, \n#                       nClasses = optimal_nclasses, \n#                       nStarts = optimal_nclasses*4, \n#                       nIter=2000, norm=T, clusterMap=F, algorithm = algorithm)\n# plot(clust$map)\n\n# file_name <- paste(date, \"areas_homogeneas\", optimal_nclasses, \"clases\", sep = \"_\")\n# terra::writeRaster(clust$map, filename = paste(path, \"areas_homogeneas/capas/\", file_name, \".tif\", sep = \"\"), overwrite = FALSE)\n\n# Explorar características de las zonas\n# clust$model\n```\n:::\n",
    "supporting": [
      "clusterizacion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}