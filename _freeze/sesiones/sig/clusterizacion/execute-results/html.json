{
  "hash": "8bb2efa956e3ae97fe47570cd352264e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Clusterización de variables ambientales\"\nformat: html\nauthor: \n  - name: \"María Suárez Muñoz\"\n    orcid: 0000-0003-1765-6885\n    email: bv2sumum@uco.es\n    affiliation: Departamento de Ingeniería Forestal, Universidad de Córdoba\ndate: 2025-02-03\nsesion: 2\ncrossref:\n  fig-title: Figura     # (default is \"Figure\")\n  tbl-title: Tabla     # (default is \"Table\")\n  title-delim: .     # (default is \":\")\n  fig-prefix: Figura\n  tbl-prefix: Tabla\n  ref-hyperlink: true\n  sec-prefix: \"\"\n  sec-labels: alpha\neditor_options: \n  chunk_output_type: console\n---\n\n\n# Introducción {.unnumbered}\n\nLa evaluación y planificación de actuaciones de un área afectada por un incendio forestal puede requerir la integración de multitud de variables en una extensión amplia del territorio. La mera observación de múltiples capas de información puede no ser suficiente a la hora de tomar decisiones. Por ello, es habitual realizar análisis de la información que nos permitan combinarla. Esta combinación puede hacerse de distintas maneras, desde técnicas estadísticas a análisis multicriterio, dependiendo de las fuentes de información que consideremos y el objetivo planteado. En esta sesión exploraremos una de estas opciones, la creación de áreas homogéneas mediante clusterización.\n\nLa creación de mapas de áreas homogéneas en virtud de distintas variables ambientales es una técnica muy utilizada para planificar actuaciones en el territorio. Esto es especialmente relevante en zonas muy extensas que no pueden ser manejadas sólo aplicando el conocimiento experto. \n\nLa idea clave de estas áreas homogéneas es que, con su creación, disponemos de una espacialización de ciertas variables, que reflejamos en un mapa. En lugar de contemplar el mundo con toda su complejidad, lo vemos sólo con la visión de las variables que hemos definido para generar dicho mapa. Es decir, podemos “leer” el territorio usando esas variables.\n\nPor ejemplo, en una zona quemada, en lugar de tener un gradiente continuo de multitud de variables descriptoras (capacidad de regeneración, profundidad del suelo, etc) tendremos una diferenciación en zonas con características acotadas, como podrían ser “lugares con suelos poco profundos y alta insolación”. De esta forma podemos plantear actuaciones de manejo particularizadas a cada unidad homogénea.\n\n# Flujo de trabajo {.unnumbered}\n\nEn esta práctica aplicaremos una clasificación no supervisada basada en el algoritmo k-means, del que puedes leer más [aquí](https://www.publichealth.columbia.edu/research/population-health-methods/k-means-cluster-analysis). Para ello trabajaremos desde `R` con las capas que hemos generado durante las prácticas con `qGIS`. El flujo de trabajo será el siguiente:\n\n1. Selección de variables\n2. Preparación de los datos\n3. Elección del número óptimo de áreas homogéneas\n4. Generación del mapa\n5. Evaluación del mapa\n\n## Selección de variables\n\nPara la creación del mapa de áreas homogéneas en primer lugar necesitaremos definir qué variables consideramos relevantes para nuestro objetivo. Una vez definidas estas variables podremos combinarlas para generar el mapa. Es habitual que tengamos que repetir el proceso varias veces, iterando sobre distintos conjuntos de variables hasta que demos con una combinación que nos satisfaga. \n\n¿Qué variables crees que pueden ser útiles para nuestro caso de uso?\n\n## Preparación de los datos\n\nEn este ejercicio utilizaremos el paquete `RStoolbox` para realizar una clasificación no supervisada. Además utilizaremos el paquete `raster` para trabajar con las capas ya que `RStoolbox` utiliza los objetos espaciales característicos de este paquete. Para otros análisis espaciales con `R` el paquete `terra` es más adecuado (más moderno, sintáxis más sencillam más intuitivo). Es importante tener cuidado al trabajar con estos dos paquetes de forma simultánea ya que existe cierto solapamiento entre funciones. Por ello si trabajamos con ambos paquetes a la vez se recomienda utilizar la sintaxis *paquete::funcion* cuando llamamos a una función, asegurándonos de estar usando la correcta. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Instalar y cargar paquetes\n# install.packages(\"RStoolbox\")\nlibrary(RStoolbox)\nlibrary(raster)\n\n# Opciones de configuración\npath <- \"...\"\n```\n:::\n\n\nEn primer lugar cargaremos las capas con las que vamos a trabajar y las exploraremos. Entonces las apilaremos en un mismo *stack*. La función *stack* del paquete `raster` crea una pila de rásters proveniente de distintos archivos. El algoritmo k-means requiere que todas las capas \"encajen\" entre sí, por lo que necesitaremos apilarlas en un stack.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargar máscara\nmask <- raster(paste0(path, \"mascara_23030.tif\"))\n\n# Cargar capas con las que vamos a trabajar: temperaturas, precipitaciones, aridez, aspecto, pendiente\ntmax <- raster(paste0(path, \"tmax_1971_2000_23030_clipbyextent.tif\"))\ntmin <- raster(paste0(path, \"tmin_1971_2000_23030_clipbyextent.tif\"))\nprec <- raster(paste0(path, \"p_1971_2000_23030_clipbyextent.tif\"))\naridez <- raster(paste0(path, \"i_aridez_23030.tif\"))\naspecto <- raster(paste0(path, \"aspecto_23030.tif\"))\npendiente <- raster(paste0(path, \"pendiente_en_grados_23030.tif\"))\n\n# Explorar capas\ntmax\ntmin\nprec\naridez\naspecto\npendiente\n\n# Apilar capas: \nmy_stack <- raster::stack(tmax, tmin, prec, aridez, aspecto, pendiente)  \n```\n:::\n\n\nHasta ahora hemos trabajado en `qGIS` con capas que tenían distintos  distintas resoluciones y sistemas de referencia, sin haber tenido problemas por ello. `qGIS` proyecta al vuelo las capas que no están en el mismo sistema de referencia que nuestro proyecto, aunque como dijimos es más adecuado reproyectar las capas para asegurarnos de que todos los cálculos se hacen correctamente. `R`, sin embargo, no hace casi nada \"under the hood\", sino que nos avisa cuando algo da problemas.\n\nAl explorar las capas hemos visto que éstas tienen distintas propiedades. Aunque sabemos que todas están en el mismo sistema de referencia, no todas tienen el sistema asignado y, además, no tienen la misma resolución y extensión. Esto hace que sus celdas no coincidan, por lo que necesitaremos *alinearlas*. Dos capas ráster están alineadas cuando están en el mismo sistema de referencia, tienen la misma resolución y el mismo origen. Es decir, que encajan en todos los aspectos. Por tanto, tendremos que asignar el sistema de coordenadas a aquellas capas que no lo tienen (**OJO**: ¡sólo cuando estamos seguros de ello!) y *remuestrear* las capas para que tengan la misma resolución y origen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Asignar sistema de coordenadas: \ncrs(aspecto) <- CRS('+init=EPSG:23030')\ncrs(pendiente) <- CRS('+init=EPSG:23030')\n\n# Reproyectar (no necesario en este caso)\n# capa_EPSG_Y <- projectRaster(capa_EPSG_X, mask_EPSG_Y)\n\n# Remuestrear: generar nueva capa con la resolución deseada\ntmax_resampled <- resample(tmax, mask, method = \"bilinear\")\ntmin_resampled <- resample(tmin, mask, method = \"bilinear\")\nprec_resampled <- resample(prec, mask, method = \"bilinear\")\naridez_resampled <- resample(aridez, mask, method = \"bilinear\")\naspecto_resampled <- resample(aspecto, mask, method = \"bilinear\")\npendiente_resampled <- resample(pendiente, mask, method = \"bilinear\")\n```\n:::\n\n\nEs importante prestar atención al método utilizado en el remuestreado, ya que el método más adecuado dependerá de la naturaleza de nuestra variable. Una vez reproyectadas y remuestreadas nuestras capas no deberíamos tener problemas para apilarlas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_stack <- raster::stack(tmax_resampled, tmin_resampled, prec_resampled, aridez_resampled, aspecto_resampled, pendiente_resampled)  \n\n# Explorar stack\nmy_stack \nplot(my_stack)\n\n# Asignar nombres a capas\nnames(my_stack) <- c(\"tmax\", \"tmin\", \"prec\", \"aridez\", \"aspecto\", \"pendiente\")\n```\n:::\n\n\nPor último, ya que el objetivo es generar un mapa de áreas homogéneas de la zona afectada por el incendio no tiene sentido considerar las zonas fuera del perímetro del mismo. Por ello, antes de proseguir aplicaremos una máscara a nuestro *stack*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enmascarar: mi máscara tiene valores 1 en la zona del incendio y no valores en la zona exterior\nstack_masked <- my_stack * mask\nnames(stack_masked) <- c(\"tmax\", \"tmin\", \"prec\", \"aridez\", \"aspecto\", \"pendiente\")\nplot(stack_masked)\n```\n:::\n\n\n## Elección del número óptimo de áreas homogéneas\n\nUna vez construida nuestra pila de variables tenemos que decidir cuántas áreas son adecuadas. Para ello es habitual realizar la clusterización con distinto número de áreas y evaluar los resultados basándonos en la variabilidad de las áreas resultantes. Para ello calcularemos la suma de cuadrados dentro de cada grupo\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Choose appropriate number of classes\nset.seed(25) # Definir semilla para obtener resultados reproducibles en procesos aleatorios, si no ejecutamos esta línea cada vez que lancemos el código obtendremos resultados ligeramente distintos.\n\nwss <- 0 # Inicializar el error de cuadrados totales (total within sum of squares error, wss)\nfor (i in 1:10) { # Ejecutar la clusterización con de 1 a 10 número de áreas\n  out <- unsuperClass(stack_masked, nClasses=i, nStarts=i*4, nIter = 2000, norm=T, clusterMap=F, algorithm = \"Hartigan-Wong\")\n  wss[i] <- out$model$tot.withinss # Guardar el wss de cada iteración\n}\nplot(1:10, wss, type = \"b\", xlab = \"Number of Clusters\", ylab = \"Within groups sum of squares\")\n```\n:::\n\n\nBasándonos en esta gráfica ¿cuál sería el número de clases óptimo?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnr_optimo <- 4\n```\n:::\n\n\n## Generación del mapa\n\nYa podemos generar el mapa de áreas homogéneas deseado ejecutando la clasificación no supervisada. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust <- unsuperClass(stack_masked, \n                      nClasses = nr_optimo, nStarts = nr_optimo*4, \n                      nIter=2000, norm=T, clusterMap=F, algorithm = \"Hartigan-Wong\")\n```\n:::\n\n\n## Evaluación del mapa\n\nPor último evaluamos el mapa obtenido y lo exportamos a un archivo ráster que podremos guardar, compartir y abrir en `qGIS` o cualquier otro SIG.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(clust$map)\n\n# Explorar características de las zonas\nclust$model\n\nwriteRaster(clust$map, filename = paste(path, \"areas_homogeneas_4_23030.tif\", sep = \"\"))\n```\n:::\n",
    "supporting": [
      "clusterizacion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}