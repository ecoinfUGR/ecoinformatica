{
  "hash": "4583b838fc488dcadd5e2654a8eacdde",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Ejercicio de bases de datos\"\nformat: html\nauthor: \n  - name: \"María Suárez Muñoz\"\n    orcid: 0000-0003-1765-6885\n    email: bv2sumum@uco.es\n    affiliation: Departamento de Ingeniería Forestal, Universidad de Córdoba\ndate: 2025-02-03\nsesion: 2\ncrossref:\n  fig-title: Figura     # (default is \"Figure\")\n  tbl-title: Tabla     # (default is \"Table\")\n  title-delim: .     # (default is \":\")\n  fig-prefix: Figura\n  tbl-prefix: Tabla\n  ref-hyperlink: true\n  sec-prefix: \"\"\n  sec-labels: alpha\n---\n\n\n\n\n# Introducción {.unnumbered}\n\n- En este ejercicio aprenderemos a trabajar con bases de datos desde `R`.\n\n- Vamos a trabajar con [R](https://www.r-project.org/), Rstudio (ahora llamado [posit](https://posit.co/)), y utilizaremos al menos los paquete [`RSQLite`](https://rsqlite.r-dbi.org/) y [`dplyr`](https://dplyr.tidyverse.org/).\n\n- El material utilizado en este manual puede descargarse [aquí](https://drive.google.com/drive/folders/1fLO-eE3Rs6zn6R18h4-MLh78WumYx-sm?usp=sharing) y este mismo ejercicio en formato .qmd puede descargarse desde [aquí](https://github.com/ecoinfUGR/ecoinformatica/blob/main/sesiones/bbdd/bbdd_ejercicio.qmd).\n\n# Flujo de Trabajo\n\n1. Instalar y cargar paquetes\n2. Crear conexión con base de datos\n3. Montar base de datos\n4. Realizar consultas\n5. Cerrar base de datos\n\n## Instalar y cargar paquetes\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"RSQLite\")\nlibrary(RSQLite)\n# install.packages(\"dplyr\")\nlibrary(dplyr)\n```\n:::\n\n\n\n\n## Crear conexión con base de datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon = dbConnect(RSQLite::SQLite(), dbname = \"material/sql.sqlite\")\ndbListTables(con)\n```\n:::\n\n\n\n\n## Montar base de datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparcelas <- read.table(\"material/ifn3p18_Convertida_Tabla_PCParcelas.txt\", sep = \";\", header = TRUE)\nmayores <- read.table(\"material/ifn3p18_Convertida_Tabla_PCMayores.txt\", sep = \";\", header = TRUE)\nmatorral <- read.table(\"material/ifn3p18_Convertida_Tabla_PCMatorral.txt\", sep = \";\", header = TRUE)\nregenera <- read.table(\"material/ifn3p18_Convertida_Tabla_PCRegenera.txt\", sep = \";\", header = TRUE)\narboles <- read.table(\"material/especies_ANEXO12.txt\", sep = \";\", header = TRUE)\narbustos <- read.table(\"material/especies_ANEXO13.txt\", sep = \";\", header = TRUE)\n\ndbWriteTable(con, \"parcelas\", parcelas)\ndbWriteTable(con, \"mayores\", mayores)\ndbWriteTable(con, \"matorral\", matorral)\ndbWriteTable(con, \"regenera\", regenera)\ndbWriteTable(con, \"arboles\", arboles)\ndbWriteTable(con, \"arbustos\", arbustos)\n\ndbListTables(con)\ndbListFields(con, \"parcelas\")\ndbReadTable(con, \"parcelas\")\n```\n:::\n\n\n\n\n## Realizar consultas\n\nUna vez creada la base de datos podemos realizar consultas sobre ella aplicando el lenguaje [SQL](https://en.wikipedia.org/wiki/SQL).\n\nPor ejemplo, quiero conocer cuáles qué especies de árboles se han observado por parcela.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery <- dbSendQuery(con, \n  \"SELECT DISTINCT Estadillo, Especie\n  FROM mayores\")\ncoexistentes <- dbFetch(query)\ndbClearResult(query)\n```\n:::\n\n\n\n\nO quiero extraer el diámetro medio de todas las encinas muestreadas y el estadillo al que pertenecen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery <- dbSendQuery(con, \n  \"SELECT Estadillo, Especie, (Dn1 + Dn2/2) AS Dn_avg\n  FROM mayores\n  WHERE Especie = 45\")\ndiam_encinas <- dbFetch(query)\ndbClearResult(query)\n```\n:::\n\n\n\n\nY también puedo realizar consultas más complejas. Por ejemplo, quiero conocer cuáles son las especies acompañantes a las encinas adultas en cada parcela.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery <- dbSendQuery(con, \n    \"SELECT DISTINCT matorral.Especie, arbustos.Nombre\n    FROM matorral\n      INNER JOIN mayores ON matorral.Estadillo=mayores.Estadillo\n      INNER JOIN arboles ON mayores.Especie = arboles.Codigo\n      INNER JOIN arbustos ON matorral.Especie = arbustos.Codigo\n    WHERE arboles.Nombre = 'Quercus ilex'\")\nacomp_encinas <- dbFetch(query)\ndbClearResult(query)\n```\n:::\n\n\n\n\nAunque el lenguaje `SQL` es el más extendida cuando hablamos de bases de datos, existen otras formas de trabajar con bases de datos que mantienen la misma lógica pero utilizan otras sintáxis.\n\nPor ejemplo, si de nuevo quiero conocer cuáles son las especies acompañantes a las encinas adultas en cada parcela...\n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacomp_encinas_dplyr <- mayores %>%\n  left_join(arboles, by = c(\"Especie\" = \"Codigo\")) %>%\n  filter(Nombre == \"Quercus ilex\") %>%\n  select(Estadillo) %>%\n  distinct() %>%\n  left_join(matorral, by = c(\"Estadillo\" = \"Estadillo\")) %>%\n  left_join(arbustos, by = c(\"Especie\" = \"Codigo\")) %>%\n  select(Especie, Nombre) %>%\n  distinct() %>%\n  filter(!is.na(Especie))\n```\n:::\n\n\n\n\n## Cerrar base de datos\n\nEL pqeute `RSQLite` requiere cerrar la conexión con la base de datos cuando terminamos de trabajar con ella.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(con)\n```\n:::\n",
    "supporting": [
      "bbdd_ejercicio_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}